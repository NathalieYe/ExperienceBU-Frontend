{"ast":null,"code":"import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\nimport { getModifier } from '@patternfly/react-styles';\n/**\n * @param {string} input - String to capitalize\n */\n\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId(prefix = 'pf') {\n  const uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView = partial && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {object} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  const func = new Function(...Object.keys(templateVars), `return \\`${templateString}\\`;`);\n  return func(...Object.values(templateVars));\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  let nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === null) {\n    getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/** This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {(DataToolbarBreakpointMod | FlexBreakpointMod | FlexItemBreakpointMod)[]} breakpointMods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport const formatBreakpointMods = (breakpointMods, styles) => breakpointMods.reduce((acc, curr) => `${acc}${acc && ' '}${getModifier(styles, `${curr.modifier}${curr.breakpoint ? `-on-${curr.breakpoint}` : ''}`)}`, '');\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);","map":{"version":3,"sources":["C:/Users/tungb/Desktop/ExperienceBU/experiencebu/node_modules/@patternfly/react-core/dist/esm/helpers/util.js"],"names":["ReactDOM","SIDE","getModifier","capitalize","input","toUpperCase","substring","getUniqueId","prefix","uid","Date","getTime","Math","random","toString","slice","debounce","func","wait","timeout","args","clearTimeout","setTimeout","apply","isElementInView","container","element","partial","containerBounds","getBoundingClientRect","elementBounds","containerBoundsLeft","floor","left","containerBoundsRight","right","elementBoundsLeft","elementBoundsRight","isTotallyInView","isPartiallyInView","sideElementIsOutOfView","isOffLeft","isOffRight","side","NONE","BOTH","RIGHT","LEFT","fillTemplate","templateString","templateVars","Function","Object","keys","values","keyHandler","index","innerIndex","position","refsCollection","kids","custom","Array","isArray","isMultiDimensional","filter","ref","constructor","nextIndex","nextInnerIndex","length","undefined","focus","findDOMNode","getNextIndex","collection","pluralize","i","singular","plural","formatBreakpointMods","breakpointMods","styles","reduce","acc","curr","modifier","breakpoint","canUseDOM","window","document","createElement"],"mappings":"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","sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\nimport { getModifier } from '@patternfly/react-styles';\n\n/**\n * @param {string} input - String to capitalize\n */\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId(prefix = 'pf') {\n  const uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView = partial && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {object} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  const func = new Function(...Object.keys(templateVars), `return \\`${templateString}\\`;`);\n  return func(...Object.values(templateVars));\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  let nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === null) {\n    getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/** This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {(DataToolbarBreakpointMod | FlexBreakpointMod | FlexItemBreakpointMod)[]} breakpointMods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport const formatBreakpointMods = (breakpointMods, styles) => breakpointMods.reduce((acc, curr) => `${acc}${acc && ' '}${getModifier(styles, `${curr.modifier}${curr.breakpoint ? `-on-${curr.breakpoint}` : ''}`)}`, '');\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}